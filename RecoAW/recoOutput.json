{"Post 5":["\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003epublic class MyClass\n { \n    MyClass(int a, int b) {\n        System.out.println(\"int a: \" + a);\n        System.out.println(\"int b: \" + b);\n    }\n    MyClass(int a) {\n        this(a, 0);\n    }\n    //...\n    public static void main(String[] args) {\n        new MyClass(1, 2);\n        new MyClass(5);\n    }\n }\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 3.14: Scope.java \n 1 public class Scope {\n 2 \n 3     public void method1(int i) {\n 4         i \u003d i++;\n 5         method2();\n 6         int j \u003d i * 2;\n 7     }\n 8 \n 9     public void method2() {\n10         int k \u003d 20;\n11     }\n12 \n13     public static void main(String[] args) {\n14         method1(10);\n15     }\n16 }\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003eCompiled from \"Foo.java\"\npublic class Foo extends java.lang.Object {\n    public Foo();\n    public static void main(java.lang.String[]);\n    public static void a();\n    public static void b();\n}\u003c/code\u003e\u003c/pre\u003e\n","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 3.1: A statement in a simple class. \n1 public class MyProgram {\n2     public static void main(String[] args) {\n3         int age \u003d 24;\n4     }\n5 }\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 1: AbstractClass.java \n1 public abstract class AbstractClass {\n2     // This method does not have a body; it is abstract.\n3     public abstract void abstractMethod();\n4  \n5     // This method does have a body; it is implemented in the abstract class and gives a default behavior.\n6     public void concreteMethod() {\n7         System.out.println(\"Already coded.\");\n8     }\n9 }\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 3.15: The default array parameter. \n1 public class ArrayExample {\n2   public static void main(String[] args) {\n3     for (int i \u003d 0; i \u003c args.length; ++i) {\n4       System.out.println(\"Argument #\" + (i + 1) + \": \" + args[i]);\n5     }\n6   }\n7 }\n Console for Code listing 3.15 \n$ java ArrayExample This is a test\nArgument #1 This\nArgument #2 is\nArgument #3 a\nArgument #4 test\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 1.5: Main. \npackage org.wikibooks.en.javaprogramming.example;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        NumberReader reader \u003d new NumberReader();\n        NumberReadListener listener \u003d new NumberReadListenerImpl();\n        reader.addNumberReadListener(listener);\n        reader.start();\n    }\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 10.1: HelloWorld.java \n 1 public class HelloWorld {\n 2  private native void print();\n 3 \n 4  public static void main(String[] args) {\n 5   new HelloWorld().print();\n 6  }\n 7 \n 8  static {\n 9   System.loadLibrary(\"HelloWorld\");\n10  }\n11 }\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 4: Creation of the multiple Thread objects running synchronously \npublic class MultiThreadExample {\n    public static boolean cthread;\n    public static String stuff \u003d \" printing material\";\n\n    public static void main(String args[]) {\n        Thread t1 \u003d new Thread(new RunnableProcess());\n        Thread t2 \u003d new Thread(new RunnableProcess());\n        t1.setName(\"Thread-1\");\n        t2.setName(\"Thread-2\");\n        t2.start();\n        t1.start();\n    }\n    /*\n     * Prints information about the current thread and the index it is\n     * on within the RunnableProcess\n     */\n    public static void printFor(int index) {\n        StringBuffer sb \u003d new StringBuffer();\n        sb.append(Thread.currentThread().getName()).append(stuff);\n        sb.append(\" for the \").append(index).append(\" time.\");\n        System.out.print(sb.toString());\n    }\n}\nclass RunnableProcess implements Runnable {\n    public void run() {\n        for(int i \u003d 0; i \u003c 10; i++) {\n            synchronized(MultiThreadExample.stuff) {\n                MultiThreadExample.printFor(i);\n                try {\n               \t    MultiThreadExample.stuff.notifyAll();\n                    MultiThreadExample.stuff.wait();\n                } catch(InterruptedException ex) {\n                   ex.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 6.2: SimpleDivisionOperation.java \n 1 public class SimpleDivisionOperation {\n 2   public static void main(String[] args) {\n 3     System.out.println(divide(4, 2));\n 4     if (args.length \u003e 1) {\n 5       // Convert a string to an integer\n 6       int arg0 \u003d Integer.parseInt(args[0]);\n 7       int arg1 \u003d Integer.parseInt(args[1]);\n 8       System.out.println(divide(arg0, arg1));\n 9     }\n10   }\n11 \n12   public static int divide(int a, int b) {\n13     if (b \u003d\u003d 0) {\n14       throw new ArithmeticException(\"You can\\\u0027t divide by zero!\");       \n15     } else {\n16       return a / b;\n17     }\n18   }\n19 }\n Output for Code listing 6.2 \n$ java SimpleDivisionOperation 1 0\n2\nException in thread \"main\" java.lang.ArithmeticException: You can\u0027t divide by zero!\nat SimpleDivisionOperation.divide(SimpleDivisionOperation.java:14)\nat SimpleDivisionOperation.main(SimpleDivisionOperation.java:7)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e"],"Post 4":["In a class, there can be several methods with the same name. However they must have a different signature. The signature of a method is comprised of its name, its parameter types and the order of its parameter. The signature of a method is not comprised of its return type nor its visibility nor its exceptions it may throw. The practice of defining two or more methods within the same class that shares the same names but different parameters is called overloading methods.\n","An interface is an abstraction of class with no implementation details. For example, java.lang.Comparable is a standard interface in Java. You cannot instantiate an interface. An interface is not a class but it is written the same way. The first difference is that you do not use the class keyword but the interface keyword to define it. Then, there are fields and methods you cannot define here:\n","Note that in addAll() we can add any type of collection. This is the beauty of using the Collection interface. You can have a LinkedList and just call the addAll(list) method, passing in a list. You can pass in a Vector, an ArrayList, a HashSet, a TreeSet, a YourImpOfCollection, ... All those different types of collection will be magically converted to a LinkedList.\n","The above code is valid because the String class is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved as Serializable object. You can call methods of the Serializable interface or cast it to String. The following collection can only contain objects that extend the class Animal.\n","In addition to instance variables of the enclosing class, local classes can also access local variables of the enclosing method, but only ones that are declared final. This is because the local class instance might outlive the invocation of the method, and so needs its own copy of the variable. To avoid problems with having two different copies of a mutable variable with the same name in the same scope, it is required to be final, so it cannot be changed.\n","This keyword is an access modifier, used before a method or other class member to signify that the method or variable can only be accessed by elements residing in its own class or classes in the same package (as it would be for the default visibility level) but moreover from subclasses of its own class, including subclasses in foreign packages (if the access is made on an expression, whose type is the type of this subclass).\n","Since Java 1.5, the class java.lang.Class is generic. It is an interesting example of using generics for something other than a container class. For example, the type of String.class is Class\u003cString\u003e, and the type of Serializable.class is Class\u003cSerializable\u003e. This can be used to improve the type safety of your reflection code. In particular, since the newInstance() method in Class now returns T, you can get more precise types when creating objects reflectively. Now we can use the newInstance() method to return a new object with exact type, without casting. An example with generics:\n","There are various ways by which you can streamline the writing of this code. You can group the declarations of similar data types in one statement, for instance:\n","To complete writing native method, you need to process your class with javah tool that will generate a header code in C. You then need to provide implementation of the header code, produce dynamically loadable library (.so under Linux, .dll under Windows) and load it (in the simplest case with System.load(library_file_name) . The code completion is trivial if only primitive types like integers are passed but gets more complex if it is needed to exchange strings or objects from the C code. In general, everything can be on C level, including creation of the new objects and calling back methods, written in java.\n","The constructor syntax is close to the method syntax. However, the constructor has the same name as the name of the class (with the same case) and the constructor has no return type. The second point is the most important difference as a method can also have the same name as the class, which is not recommended:\n"],"Post 7":["Processes perform simple operations to write new objects into a JavaSpace, take objects from a JavaSpace, or read (make a copy of) objects from the JavaSpace.\n","An array created using new Object[10] has 10 null pointers. That\u0027s 10 more than we want, so use collections instead, or explicitly fill the array at initialization with: Code section 6.19: Declaring an exception. \n1 Object[] objects \u003d {\"blah\", 5, new File(\"/usr/bin\")};\n\n or: Code section 6.20: Declaring an exception. \n1 Object[] objects;\n2 objects \u003d new Object[]{\"blah\", 5, new File(\"/usr/bin\")};\n","99% of new objects are created using the new keyword.\n","Open up your editing program and create a new file saved as Loop.java. Now type or copy the following code:\n","Object object ⇔ new Object()\n","Java has the concepts of cloning object, and the end results are similar to copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.\n","You might think that accessing the private memberVar variable of obj would fail but as this is in the same class this code is legal. The clone() method copies the whole object\u0027s memory in one operation. This is much faster than using the new keyword. Object creation with the new keyword is expensive, so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.\n","The java.lang.Object.clone() method returns a new object that is a copy of the current object. Classes must implement the marker interface java.lang.Cloneable to indicate that they can be cloned.\n","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 2: Creating Thread objects \npublic class ThreadLogic {\n    public static void main(String[] args) {\n        Thread t1 \u003d new Thread(new RunnableProcess(\"Thread-1\"));\n        Thread t2 \u003d new Thread(new RunnableProcess(\"Thread-2\"));\n        Thread t3 \u003d new Thread(new RunnableProcess(\"Thread-3\"));\n    }\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","new is a Java keyword. It creates a Java object and allocates memory for it on the heap. new is also used for array creation, as arrays are also objects.\n"],"Post 6":["Java has the concepts of cloning object, and the end results are similar to copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.\n","Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the protected Object clone() method. This base method would allocate the memory and do the bit by bit copying of the object\u0027s states.\n","Now each time we add an item to the collection, it is a different instance. All the items evolve separately. To add an object in a collection and avoid this item to be changed each time the source object is changed, you have to copy or clone the object before you add it to the collection.\n","Upon creating a variable, we basically create a new address space and give it a unique name. Java goes one step further and lets you define what you can place within the variable — in Java parlance you call this a data type. So, you essentially have to do two things in order to create a variable:\n","You might think that accessing the private memberVar variable of obj would fail but as this is in the same class this code is legal. The clone() method copies the whole object\u0027s memory in one operation. This is much faster than using the new keyword. Object creation with the new keyword is expensive, so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.\n","In the code listing 4.15 we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let\u0027s say we want to store Customer objects in a collection, but we want to disassociate them from the \u0027live\u0027 objects. So before adding the object, we clone them, so if the original object changes from that point forward, the added object won\u0027t. Also let\u0027s say that the Customer object has a reference to an Activity object that contains the customer activities. Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects. The solution:\n","After J2EE, Sun had a vision about the next step of network computing: in a network environment, there would be many independent services and consumers. That is JavaSpaces. JavaSpaces would allow these services/consumers to interact dynamically with each other in a robust way. It can be viewed as an object repository that provides a distributed persistent object exchange mechanism (persistent can be in memory or disk) for Java objects. It can be used to store the system state and implement distributed algorithms. In a JavaSpace, all communication partners (peers) communicate by sharing state. It is an implementation of the Tuple spaces idea.\n","The java.lang.Object.clone() method returns a new object that is a copy of the current object. Classes must implement the marker interface java.lang.Cloneable to indicate that they can be cloned.\n","Objects put into a collection are upcasted to Object class. It means that you need to cast the object reference back when you get an element out from the collection. It also means that you need to know the type of the object when you take it out. If a collection contains different types of objects, we will have difficulty finding out the type of the objects obtained from a collection at run time. Let\u0027s use a collection with any objects in it:\n","Processes perform simple operations to write new objects into a JavaSpace, take objects from a JavaSpace, or read (make a copy of) objects from the JavaSpace.\n"],"Post 1":["A copy constructor is not included in the Java language, however one can easily create a constructor that do the same as a copy constructor. It\u0027s important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.\n","In addition to instance variables of the enclosing class, local classes can also access local variables of the enclosing method, but only ones that are declared final. This is because the local class instance might outlive the invocation of the method, and so needs its own copy of the variable. To avoid problems with having two different copies of a mutable variable with the same name in the same scope, it is required to be final, so it cannot be changed.\n","By convention, a constructor that accepts an object of its own type as a parameter and copies the data members is called a copy constructor. One interesting feature of constructors is that if and only if you do not specify a constructor in your class, the compiler will create one for you. This default constructor, if written out would look like:\n","Java has the concepts of cloning object, and the end results are similar to copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.\n","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 1.4: COM_DATA \n /**\n  * COM_DATA data structure \n  */\n public class COM_DATA implements Serializable\n {\n  public String  comData;\n  public boolean bExit;\n  public int     iRet;\n    /**\n     * --- Constants values can be passed in in iRet to the Server ---\n     */\n    static final int WAIT_FOR_RESPONSE    \u003d 0;\n    static final int NOWAIT_FOR_RESPONSE  \u003d 1;\n   /**\n    * Initialize the data structure\n    */\n   public COM_DATA()\n   {\n      comData     \u003d \"\";\n      bExit       \u003d false;\n      iRet        \u003d 0;\n   } // -- End of COM_DATA() Constructor --   \n   /**\n    * Copy over it contents \n    */\n   public void copy( COM_DATA tSrc )\n   {\n      this.comData     \u003d tSrc.comData;\n      this.bExit       \u003d tSrc.bExit;\n      this.iRet        \u003d tSrc.iRet;\n    return;\n   } \n } // -- End of COM_DATA class --\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 4.1: Employee.java \n 1 public class Employee {              // This defines the Employee class.\n 2                                      // The public modifier indicates that\n 3                                      // it can be accessed by any other class\n 4 \n 5     private static int nextID;       // Define a static field. Only one copy of this will exist,\n 6                                      // no matter how many Employees are created.\n 7 \n 8     private int myID;                // Define fields that will be stored  \n 9     private String myName;           // for each Employee. The private modifier indicates that\n10                                      // only code inside the Employee class can access it.\n11  \n12     public Employee(String name) {   // This is a constructor. You can pass a name to the constructor\n13                                      // and it will give you a newly created Employee object.\n14         myName \u003d name;\n15         myID \u003d nextID;               // Automatically assign an ID to the object\n16         nextID++;                    // Increment the ID counter\n17     }\n18  \n19     public String getName() {        // This is a member method that returns the\n20                                      // Employee object\u0027s name.\n21         return myName;               // Note how it can access the private field myName.\n22     }\n23  \n24     public int getID() {             // This is another member method.\n25    \n26         return myID;  \n27     }\n28  \n29     public static int getNextID() {  // This is a static method that returns the next ID\n30                                      // that will be assigned if another Employee is created.\n31         return nextID;\n32     }\n33 }\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","Below is an example of an immutable public class named Length which maintains private instance fields named units and magnitude but provides a public constructor and two public accessor methods.\n","Now each time we add an item to the collection, it is a different instance. All the items evolve separately. To add an object in a collection and avoid this item to be changed each time the source object is changed, you have to copy or clone the object before you add it to the collection.\n","You might think that accessing the private memberVar variable of obj would fail but as this is in the same class this code is legal. The clone() method copies the whole object\u0027s memory in one operation. This is much faster than using the new keyword. Object creation with the new keyword is expensive, so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.\n","In this example, the constructor of the Plane class calls the constructor of its superclass Vehicle. You can only use super to access the members of the superclass inside the child class. If you use it from another class, it accesses the superclass of the other class. This keyword also allows you to explicitly access the members of the superclass, for instance, in the case where there is a method with the same name in your class (overriding, ...). Example :\n"],"Post 3":["That seems like a lot, but it\u0027s pretty simple once you get used to it. Take a look at the image on the left, which contains a general example of how you might use the framework. In this example we have a class called EventSourceClass that publishes interesting events. Following the rules of the Event Model, the events are represented by the InterestingEvent class which has a reference back to the EventSourceClass object (source, inherited from java.util.EventObject).\n","The reason we need it is because many times, we need to create an object reference before the object itself is created. Object references cannot exist without a value, so we assign the null value to it. Code section 6.14: Non-instantiated declared object. \n1 public Person getPerson(boolean isWoman) {\n2   Person person \u003d null;\n3   if (isWoman) {\n4     person \u003d createWoman();\n5   } else {\n6     person \u003d createMan();\n7   }\n8   return person;\n9 }\n In the code section 6.14 we want to create the Person inside the if-else, but we also want to return the object reference to the caller, so we need to create the object reference outside of the if-else, because of the scoping rule in Java. Incorrect error-handling and poor contract design can be a pitfall with any programming language. This is also true for Java. Now we will describe how to prevent NullPointerException. It does not describe general techniques for how you should program Java. It is of some use, to make you more aware of null values, and to be more careful about generating them yourself. This list is not complete — there are no rules for preventing NullPointerException entirely in Java, because the standard libraries have to be used, and they can cause NullPointerExceptions. Also, it is possible to observe an uninitialized final field in Java, so you can\u0027t even treat a final field as being completely trusted during the object\u0027s creation. A good approach is to learn how to deal with NullPointerExceptions first, and become competent with that. These suggestions will help you to cause less NullPointerExceptions, but they don\u0027t replace the need to know about NullPointerExceptions.\n","An interface is an abstraction of class with no implementation details. For example, java.lang.Comparable is a standard interface in Java. You cannot instantiate an interface. An interface is not a class but it is written the same way. The first difference is that you do not use the class keyword but the interface keyword to define it. Then, there are fields and methods you cannot define here:\n","If you have objects from different classes that do not have common superclasses, you can\u0027t call a same method on them, even if the two classes implement a method with the same signature.\n","Objects put into a collection are upcasted to Object class. It means that you need to cast the object reference back when you get an element out from the collection. It also means that you need to know the type of the object when you take it out. If a collection contains different types of objects, we will have difficulty finding out the type of the objects obtained from a collection at run time. Let\u0027s use a collection with any objects in it:\n","Input streams acquire bytes for our programmed java application/program (e.g. a file, an array, a keyboard or monitor, etc.). InputStream is an abstract class that represents a source of byte data. It has a read() method, which returns the next byte in the stream and a close() method, which should be called by a program when that program is done with the stream. The read() method is overloaded, and can take a byte array to read to. It has a skip() method that can skip a number of bytes, and an available() method that a program can use to determine the number of bytes immediately available to be read, as not all the data is necessarily ready immediately. As an abstract class, it cannot be instantiated, but describes the general behavior of an input stream. A few examples of concrete subclasses would be ByteArrayInputStream, which reads from a byte array, and FileInputStream, which reads byte data from a file.\n","A package is a name space that mainly contains classes and interfaces. For instance, the standard class ArrayList is in the package java.util. For this class, java.util.ArrayList is called its fully qualified name because this syntax has no ambiguity. Classes in different packages can have the same name. For example, you have the two classes java.util.Date and java.sql.Date which are not the same. If no package is declared in a class, its package is the default package.\n","You can see that the method1() method is abstract (unimplemented). To use an interface, you have to define a class that implements it, using the implements keyword:\n","Reflection is the mechanism by which Java exposes the features of a class during runtime, allowing Java programs to enumerate and access a class\u0027 methods, fields, and constructors as objects. In other words, there are object-based mirrors that reflect the Java object model, and you can use these objects to access an object\u0027s features using runtime API constructs instead of compile-time language constructs. Each object instance has a getClass() method, inherited from java.lang.Object, which returns an object with the runtime representation of that object\u0027s class; this object is an instance of the java.lang.Class, which in turn has methods that return the fields, methods, constructors, superclass, and other properties of that class. You can use these reflection objects to access fields, invoke methods, or instantiate instances, all without having compile-time dependencies on those features. The Java runtime provides the corresponding classes for reflection. Most of the Java classes that support reflection are in the java.lang.reflect package. Reflection is most useful for performing dynamic operations with Java — operations that are not hard-coded into a source program, but that are determined at run time. One of the most important aspects of reflection is dynamic class loading.\n","In Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.\n"],"Post 2":["What happens if I pack a newer version of an utility library with my application, while an older version of the same library lingers somewhere in the server\u0027s lib directory? How can I use two different versions of the same utility library, simultaneously, within the same instance of the application server? What version of an utility class I am currently using? Why do I need to mess with all this class loading stuff anyway?\n","Versions of Java prior to J2SE 1.4 only supported stream-based blocking I/O. This required a thread per stream being handled, as no other processing could take place while the active thread blocked waiting for input or output. This was a major scalability and performance issue for anyone needing to implement any Java network service. Since the introduction of NIO (New I/O) in J2SE 1.4, this scalability problem has been rectified by the introduction of a non-blocking I/O framework (though there are a number of open issues in the NIO API as implemented by Oracle).\n","There is a problem, though. What if I put two different type of objects to the Set. I put an Apple and an Orange. They can not be compared. Calling the equals() method would cause a ClassCastException. There are two solutions to this:\n","Coding drawing, to begin with, is pretty daunting but once you know the basics of Graphics programming in Java, you can create elegant graphics and art in no time. But the question that arises in one\u0027s mind is what to draw on. The answer to this question is simpler than it seems. You can start drawing on any component in the Java framework. Whether it be a panel, window or even a button.\n","Question 9.1: What classes are used to draw in Java? Any class that is derived from the Object class. Any class that is derived from the Component class. None of the above. Question 9.2: What is the method that needs to be overridden in order to enable drawing? The main(String[]) method. The MyCanvas() method. The paint(Graphics) method. None of the above.\n","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode section 3.36: A double for loop. \n 1 int i, j;\n 2 int[][] nums \u003d {\n 3     {1, 2, 5},\n 4     {6, 9, 7},\n 5     {8, 3, 4}\n 6 };\n 7 \n 8 Outer:\n 9 for (i \u003d 0; i \u003c nums.length; i++) {\n10     for (j \u003d 0; j \u003c nums[i].length; j++) {\n11         if (nums[i][j] \u003d\u003d 9) {\n12             System.out.println(\"Found number 9 at (\" + i + \", \" + j + \")\");\n13             break Outer;\n14         }\n15     }\n16 }\n Output for code section 3.36 \nFound number 9 at (1, 1)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eCode listing 3.15: The default array parameter. \n1 public class ArrayExample {\n2   public static void main(String[] args) {\n3     for (int i \u003d 0; i \u003c args.length; ++i) {\n4       System.out.println(\"Argument #\" + (i + 1) + \": \" + args[i]);\n5     }\n6   }\n7 }\n Console for Code listing 3.15 \n$ java ArrayExample This is a test\nArgument #1 This\nArgument #2 is\nArgument #3 a\nArgument #4 test\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","If only one statement is to be executed after an if block, it does not have to be enclosed in curly braces. For example, if (i \u003d\u003d 0) i \u003d 1; is a perfectly valid portion of Java code. This works for most control structures, such as else and while. However Oracle\u0027s Java Code Conventions explicitly state that the braces should always be used.\n","Notice that in the expression starting with if ((D \u003d\u003d 0), I have to use OR instead of the || because of a bug in the source template.\n","JNIEXPORT jint JNICALL Java_IntArray_sumArray\n        (JNIEnv *env, jobject obj, jintArray arr) {\n    jint buf[10];\n    jint i, sum \u003d 0;\n    // This line is necessary, since Java arrays are not guaranteed\n    // to have a continuous memory layout like C arrays.\n    env-\u003eGetIntArrayRegion(arr, 0, 10, buf);\n    for (i \u003d 0; i \u003c 10; i++) {\n        sum +\u003d buf[i];\n    }\n    return sum;\n}\n"],"Post 10":["Anonymous classes are most useful to create an instance of an interface or adapter class without needing a brand new class.\n","Since Java 1.5, the class java.lang.Class is generic. It is an interesting example of using generics for something other than a container class. For example, the type of String.class is Class\u003cString\u003e, and the type of Serializable.class is Class\u003cSerializable\u003e. This can be used to improve the type safety of your reflection code. In particular, since the newInstance() method in Class now returns T, you can get more precise types when creating objects reflectively. Now we can use the newInstance() method to return a new object with exact type, without casting. An example with generics:\n","There is a better approach. Defines special return object with the needed return values. Create that object inside the method, assign the values and return the reference to this object. This special object is \"bound\" to this method and used only for returning values, so do not use a public class. The best way is to use a nested class, see example below:\n","transient is a Java keyword which marks a member variable not to be serialized when it is persisted to streams of bytes. When an object is transferred through the network, the object needs to be \u0027serialized\u0027. Serialization converts the object state to serial bytes. Those bytes are sent over the network and the object is recreated from those bytes. Member variables marked by the java transient keyword are not transferred; they are lost intentionally.\n","Java has built-in support for serialization, using the Serializable interface; however, a class must first implement the Serializable interface.\n","Objects passed in as parameters to the remote objects\u0027s methods will be passed by value. If the remote object changes the passed-in object values, it won\u0027t be reflected on the client side, this is opposite what happens when a local object is called. Objects that used as parameters for remote methods invocation must implement the java.io.Serializable interface, as they are going to be serialized when passed through the network, and a new object will be created on the other side.\n","The final keyword is mostly used to guarantee a good usage of the code. For instance (non-static) methods, this allows the compiler to expand the method (similar to an inline function) if the method is small enough. Sometimes it is required to use it. For instance, a nested class can only access the members of the top-level class if they are final.\n","Object Serialization  The term Object Serialization refers to the act of converting the object to a byte stream. The byte stream can be stored on the file system, or can be sent through a network. At the later time the object can be re-created from that stream of bytes. The only requirement is that the same class has to be available at both times, when the object is serialized and also when the object is re-created. If that happens in different servers, then the same class must be available on both servers. Same class means that exactly the same version of the class must be available, otherwise the object won\u0027t be able to be re-created. This is a maintenance problem to those applications where java serialization is used to persist object or sent the object through the network. When a class is modified, there could be a problem re-creating those objects that were serialized using an earlier version of the class.\n","In Java, there are several existing methods that already sort objects from any class like Collections.sort(List\u003cT\u003e list). However, Java needs to know the comparison rules between two objects. So when you define a new class and want the objects of your class to be sortable, you have to implement the Comparable and redefine the compareTo(Object obj) method.\n","A copy constructor is not included in the Java language, however one can easily create a constructor that do the same as a copy constructor. It\u0027s important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.\n"],"Post 9":["Java language was developed having network computing in mind. For this reason it is very easy to create a server program. A server is a piece of code that runs all the time listening on a particular port on the computer for incoming request. When a request arrives, it starts a new thread to service the request. See the following example:\n","The lookup service is described in the : Jini Lookup Service Specification (reggie). This service interface defines all operations that are possible on the lookup service. Clients locate services by requesting with a lookup server that implements a particular interface. Client asks the lookup server for all services that implement the particular service interface. The lookup service returns service objects for all registered services that implement the given interface. The client may invoke methods on that object in order to interact directly with the server.\n","By convention, a constructor that accepts an object of its own type as a parameter and copies the data members is called a copy constructor. One interesting feature of constructors is that if and only if you do not specify a constructor in your class, the compiler will create one for you. This default constructor, if written out would look like:\n","You can notice that when you use System.out.println(), out is a static attribute of the System class. A static attribute is related to a class, not to any object instance, so there is only one value for all the object instances. This attribute is unique in the whole Java Virtual Machine. All the object instances use the same attribute:\n","But in the mid 90\u0027s, with the prices of Unix servers dropping, the trend was moving away from Mainframe computing toward Client-Server computing. This would enable rich clients to be developed on workstations while they would communicate with a centralized server, serving computers connected to it, to either communicate with other workstations also connected to it or it would request for database access or business logic stored on the server itself. The workstations were called clients.\n","The reason that the Java platform doesn\u0027t offer one general implementation of event-driven programming is linked to the origins of the support that the platform does offer. Back in 1996 the Java programming language was just getting started in the world and was still trying to gain a foothold and conquer a place for itself in software development. Part of this early development concentrated on software development tooling like IDEs. One of the trends in software development around that time was for reusable software components geared towards user interfaces: components that would encapsulate some sort of interesting, reusable functionality into a single package that could be handled as a single entity rather than as a loose collection of individual classes. Sun Microsystems tried to get on the component bandwagon by introducing what they called a JavaBean, a software component not only geared towards the UI but that could also be configured easily from an IDE. In order to make this happen Sun came up with a large specification of JavaBeans (the JavaBeans Spec) dealing mostly with naming conventions (to make the components easy to handle from an IDE). But Sun also realized at the same time that a UI-centric component would need support for an event-driven way of connecting events in the component to business logic that would have to be written by the individual developer. So the JavaBeans Spec also included a small specification for an event Model for the Java platform.\n","\u003cpre\u003e\u003ccode\u003e\u003cspan style\u003d\u0027background-color\u0027:\u0027#F2A4A4\u0027\u003eComServerThread  This class extended from a Thread; Responsible to service one client. The Socket connection will be open between the client and server. A simple protocol has to be defined between the client and server, the server has to understand what the client wants from the server. The client will send a terminate command, for which the server will terminate the socket connection. The ComServerThread class is responsible to handle a client request, until the client sends a terminate command.\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","You might think that accessing the private memberVar variable of obj would fail but as this is in the same class this code is legal. The clone() method copies the whole object\u0027s memory in one operation. This is much faster than using the new keyword. Object creation with the new keyword is expensive, so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.\n","Sometime it is desirable to catch all exception for logging purposes, then throw it back on. For example, in servlet programming when application server calls the server doPost(), we want to monitor that no exception even runtime exception happened during serving the request. The application has its own logging separate from the server logging. The runtime exceptions would just go through without detecting it by the application. The following code would check all exceptions, log them, and throw it back again.\n","Lets see how this new found knowledge of the basic integer types in Java fits into the picture. Say, you want to numerically manipulate the days in a year — all 365 days. What type would you use? Since the data type byte only goes up to 127, would you risk giving it a value greater than its allowed maximum. Such decisions might save you from dreaded errors that might occur out of the programmed code. A much more sensible choice for such a numeric operation might be a short. Oh, why couldn\u0027t they make just one data type to hold all kinds of numbers? Wouldn\u0027t you ask that question? Well, let\u0027s explore why.\n"],"Post 8":["String is a class built into the Java language defined in the java.lang package. It represents character strings. Strings are ubiquitous in Java. Study the String class and its methods carefully. It will serve you well to know how to manipulate them skillfully. String literals in Java programs, such as \"abc\", are implemented as instances of this class like this:\n","Annotations can provide metadata for java classes, attributes, and methods. Syntactically, annotations can be viewed as special kind of modifier and can be used anywhere that other modifiers (such as public, static, or final) can be used\n","If you are importing library packages or classes that reside in a .jar file, you must ensure that the file is in the current classpath (both at compile- and execution-time). Apart from this requirement, importing these packages and classes is the same as if they were in their full, expanded, directory structure.\n","For example, to compile and run a class from a project\u0027s top directory (that contains the two directories /source and /libraries) you could use the following command:\n","Although Java comes with the Java 3D library other libraries have been developed over time with similar functionality. Thus, unlike many other areas of Java development explored in this book, a Java programmer has a choice to make as to which 3D library to use.\n","Examples of keywords are the primitive types, int and boolean; the control flow statements for and if; access modifiers such as public, and special words which mark the declaration and definition of Java classes, packages, and interfaces: class, package, interface.\n","The Java Native Interface (JNI) enables Java code running in a Java Virtual Machine (JVM) to call and to be called by native applications (programs specific to a hardware and operating system platform) and libraries written in other languages, such as C, C++ and assembly.\n","As decimal numbers such as 1995, 51966. Negative decimal numbers such as -42 are actually expressions consisting of the integer literal with the unary negation operation -. As octal numbers, using a leading 0 (zero) digit and one or more additional octal digits (digits between 0 and 7), such as 077. Octal numbers may evaluate to negative numbers; for example 037777777770 is actually the decimal value -8. As hexadecimal numbers, using the form 0x (or 0X) followed by one or more hexadecimal digits (digits from 0 to 9, a to f or A to F). For example, 0xCAFEBABEL is the long integer 3405691582. Like octal numbers, hexadecimal literals may represent negative numbers. Starting in J2SE 7.0, as binary numbers, using the form 0b (or 0B) followed by one or more binary digits (0 or 1). For example, 0b101010 is the integer 42. Like octal and hex numbers, binary literals may represent negative numbers.\n","Dynamic Class Loading allows the loading of java code that is not known about before a program starts. Many classes rely on other classes and resources such as icons which make loading a single class unfeasible. For this reason the ClassLoader (java.lang.ClassLoader) is used to manage all the inner dependencies of a collection of classes. The Java model loads classes as needed and doesn\u0027t need to know the name of all classes in a collection before any one of its classes can be loaded and run.\n","Make the Activity class also cloneable Make sure that if the Activity class has other \u0027changeable\u0027 object references, those has to be cloned as well, as seen below Change the Customer class clone() method as follows:\n"]}